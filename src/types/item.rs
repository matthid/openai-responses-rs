use super::{APIInputMessage, Role};
use serde::{
    Deserialize, Deserializer, Serialize, Serializer, de::Error as DeError, ser::SerializeMap,
};
use std::collections::HashMap;

/// Content items generated by the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OutputItem {
    /// An output message from the model.
    Message(OutputMessage),
    /// The results of a file search tool call. See the [file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.
    #[serde(rename = "file_search_call")]
    FileSearch(FileSearchCall),
    /// A tool call to run a function. See the [function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.
    FunctionCall(FunctionCall),
    /// An image generation call output.
    #[serde(rename = "image_generation_call")]
    ImageGenerationCall(ImageGenerationCall),
    /// The results of a web search tool call. See the [web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.
    #[serde(rename = "web_search_call")]
    WebSearchResults(WebSearchCall),
    /// A tool call to a computer use tool. See the [computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.
    #[serde(rename = "computer_call")]
    ComputerToolCall(ComputerToolCall),
    /// A description of the chain of thought used by a reasoning model while generating a response.
    Reasoning(Reasoning),
}

/// An item representing part of the context for the response to be generated by the model.
///
/// Can contain text, images, and audio inputs, as well as previous assistant responses and tool call outputs.
/// An item representing part of the context for the response to be generated by the model.
///
/// Can contain text, images, and audio inputs, as well as previous assistant responses and tool call outputs.
#[derive(Debug, Clone)]
pub enum InputItem {
    /// A message input to the model with a role indicating instruction following hierarchy.
    ///
    /// Instructions given with the `Developer` or `System` role take precedence over instructions given with the `User` role.
    InputMessage(APIInputMessage),
    /// An output message from the model.
    OutputMessage(OutputMessage),
    /// The results of a file search tool call.
    FileSearch(FileSearchCall),
    /// A tool call to run a computer use tool.
    ComputerToolCall(ComputerToolCall),
    /// The output of a computer tool call.
    ComputerToolCallOutput(ComputerToolCallOutput),
    /// The results of a web search tool call.
    WebSearchResults(WebSearchCall),
    /// A tool call to run a function.
    FunctionCall(FunctionCall),
    /// The output of a function tool call.
    FunctionCallOutput(FunctionCallOutput),
    /// A description of the chain of thought used by a reasoning model while generating a response.
    Reasoning(Reasoning),
}
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
enum InputItemType {
    Message,
    FileSearchCall,
    ComputerToolCall,
    ComputerToolCallOutput,
    WebSearchResults,
    FunctionCall,
    FunctionCallOutput,
    Reasoning,
}

impl InputItemType {
    // handy helper for code that still needs &str
    const fn as_str(self) -> &'static str {
        match self {
            InputItemType::Message => "message",
            InputItemType::FileSearchCall => "file_search_call",
            InputItemType::ComputerToolCall => "computer_call",
            InputItemType::ComputerToolCallOutput => "computer_call_output",
            InputItemType::WebSearchResults => "web_search_call",
            InputItemType::FunctionCall => "function_call",
            InputItemType::FunctionCallOutput => "function_call_output",
            InputItemType::Reasoning => "reasoning",
        }
    }

    fn from_str(str: &str) -> Option<InputItemType> {
        match str {
            "message" => Some(InputItemType::Message),
            "file_search_call" => Some(InputItemType::FileSearchCall),
            "computer_call" => Some(InputItemType::ComputerToolCall),
            "computer_call_output" => Some(InputItemType::ComputerToolCallOutput),
            "web_search_call" => Some(InputItemType::WebSearchResults),
            "function_call" => Some(InputItemType::FunctionCall),
            "function_call_output" => Some(InputItemType::FunctionCallOutput),
            "reasoning" => Some(InputItemType::Reasoning),
            _ => None,
        }
    }
    // handy helper for code that still needs &str
    const fn from_item(item: &InputItem) -> InputItemType {
        match item {
            InputItem::InputMessage(_) => InputItemType::Message,
            InputItem::OutputMessage(_) => InputItemType::Message,
            InputItem::FileSearch(_) => InputItemType::FileSearchCall,
            InputItem::ComputerToolCall(_) => InputItemType::ComputerToolCall,
            InputItem::ComputerToolCallOutput(_) => InputItemType::ComputerToolCallOutput,
            InputItem::WebSearchResults(_) => InputItemType::WebSearchResults,
            InputItem::FunctionCall(_) => InputItemType::FunctionCall,
            InputItem::FunctionCallOutput(_) => InputItemType::FunctionCallOutput,
            InputItem::Reasoning(_) => InputItemType::Reasoning,
        }
    }
}
#[derive(Serialize)]
struct WithType<'a, T: Serialize> {
    #[serde(rename = "type")]
    kind: &'static str, // the discriminator
    #[serde(flatten)]
    inner: &'a T, // all the real data
}

impl Serialize for InputItem {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let type_str = InputItemType::from_item(self).as_str();
        match self {
            InputItem::InputMessage(msg) => {
                // compute  "status" field only if Some(_)
                let extra = if msg.status.is_some() { 1 } else { 0 };
                let mut map = serializer.serialize_map(Some(2 + extra))?;
                map.serialize_entry("type", type_str)?;
                map.serialize_entry("role", &msg.role)?;
                map.serialize_entry("content", &msg.content)?;
                if let Some(status) = &msg.status {
                    map.serialize_entry("status", status)?;
                }
                map.end()
            }
            InputItem::OutputMessage(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::FileSearch(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::ComputerToolCall(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::ComputerToolCallOutput(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::WebSearchResults(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::FunctionCall(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::FunctionCallOutput(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
            InputItem::Reasoning(msg) => WithType {
                kind: type_str,
                inner: msg,
            }
            .serialize(serializer),
        }
    }
}

impl<'de> Deserialize<'de> for InputItem {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // read whole object once
        let mut map: serde_json::Map<String, serde_json::Value> =
            Deserialize::deserialize(deserializer)?;

        let tag = map
            .remove("type")
            .and_then(|v| v.as_str().map(str::to_owned))
            .ok_or_else(|| D::Error::missing_field("type"))?;

        let has_id = map.contains_key("id");
        let inner = serde_json::Value::Object(map);

        // helper to avoid writing from_value(..).map_err(..) eight times
        fn conv<T, E>(v: serde_json::Value) -> Result<T, E>
        where
            T: for<'a> Deserialize<'a>,
            E: serde::de::Error,
        {
            serde_json::from_value(v).map_err(E::custom)
        }

        let tag = InputItemType::from_str(tag.as_str())
            .ok_or_else(|| D::Error::custom(format!("unknown type tag: {tag}")))?;

        match tag {
            InputItemType::Message => {
                if has_id {
                    Ok(InputItem::OutputMessage(conv(inner)?))
                } else {
                    Ok(InputItem::InputMessage(conv(inner)?))
                }
            }

            InputItemType::FileSearchCall => Ok(InputItem::FileSearch(conv(inner)?)),
            InputItemType::ComputerToolCall => Ok(InputItem::ComputerToolCall(conv(inner)?)),
            InputItemType::ComputerToolCallOutput => {
                Ok(InputItem::ComputerToolCallOutput(conv(inner)?))
            }
            InputItemType::WebSearchResults => Ok(InputItem::WebSearchResults(conv(inner)?)),
            InputItemType::FunctionCall => Ok(InputItem::FunctionCall(conv(inner)?)),
            InputItemType::FunctionCallOutput => Ok(InputItem::FunctionCallOutput(conv(inner)?)),
            InputItemType::Reasoning => Ok(InputItem::Reasoning(conv(inner)?)),
        }
    }
}

/// An output message from the model.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct OutputMessage {
    /// The content of the output message.
    pub content: Vec<OutputContent>,
    /// The unique ID of the output message.
    pub id: String,
    /// The role of the output message. Always `Assistant`.
    pub role: Role,
    /// The status of the message input.
    pub status: MessageStatus,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ImageGenerationCall {
    /// Base64-encoded image data returned by the tool.
    pub result: Option<String>,
}

/// The content of the output message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum OutputContent {
    /// A text output from the model.
    #[serde(rename = "output_text")]
    Text {
        /// The text output from the model.
        text: String,
        /// The annotations of the text output.
        annotations: Vec<Annotation>,
    },
    /// A refusal from the model.
    Refusal {
        /// The refusal explanation from the model.
        refusal: String,
    },
}

/// The content of the summary message.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum SummaryContent {
    #[serde(rename = "summary_text")]
    Text {
        /// The text of the summary part.
        text: String,
    },
}

/// An annotation of the text output.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum Annotation {
    /// A citation to a file.
    FileCitation {
        /// The ID of the file.
        file_id: String,
        /// The index of the file in the list of files.
        index: u64,
    },
    #[serde(rename = "url_citation")]
    /// A citation for a web resource used to generate a model response.
    URLCitation {
        /// The index of the last character of the URL citation in the message.
        end_index: u64,
        /// The index of the first character of the URL citation in the message.
        start_index: u64,
        /// The title of the web resource.
        title: String,
        /// The URL of the web resource.
        url: String,
    },
    /// A path to a file.
    FilePath {
        /// The ID of the file.
        file_id: String,
        /// The index of the file in the list of files.
        index: u64,
    },
}

/// The status of a message.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum MessageStatus {
    InProgress,
    Completed,
    Incomplete,
}

/// The results of a file search tool call.
///
/// See the [file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileSearchCall {
    /// The unique ID of the file search tool call.
    pub id: String,
    /// The queries used to search for files.
    pub queries: Vec<String>,
    /// The status of the file search tool call.
    pub status: FileSearchStatus,
    /// The results of the file search tool call.
    pub results: Option<Vec<FileSearchResult>>,
}

/// A result of the file search tool call.
///
/// See the [file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FileSearchResult {
    /// Set of 16 key-value pairs that can be attached to an object.
    ///
    /// This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.
    /// Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters, booleans, or numbers.
    pub attributes: HashMap<String, String>,
    /// The unique ID of the file.
    pub file_id: String,
    /// The name of the file.
    pub filename: String,
    /// The relevance score of the file - a value between 0 and 1.
    pub score: f32,
    /// The text that was retrieved from the file.
    pub text: String,
}

/// The status of the file search tool call.
///
/// See the [file search guide](https://platform.openai.com/docs/guides/tools-file-search) for more information.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum FileSearchStatus {
    Completed,
    InProgress,
    Searching,
    Incomplete,
    Failed,
}

/// A tool call to run a function.
///
/// See the [function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCall {
    /// A JSON string of the arguments to pass to the function.
    pub arguments: String,
    /// The unique ID of the function tool call generated by the model.
    pub call_id: String,
    /// The unique ID of the function tool call.
    pub id: Option<String>,
    /// The name of the function to run.
    pub name: String,
    /// The status of the item.
    pub status: Option<FunctionCallStatus>,
}

/// The status of the function call.
///
/// See the [function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq)]
#[serde(rename_all = "snake_case")]
pub enum FunctionCallStatus {
    InProgress,
    Completed,
    Incomplete,
}

/// The output of a function call.
///
/// See the [function calling guide](https://platform.openai.com/docs/guides/function-calling) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FunctionCallOutput {
    /// The unique ID of the function tool call output. Populated when this item is returned via API.
    pub id: Option<String>,
    /// The status of the item. Populated when items are returned via API.
    pub status: Option<FunctionCallStatus>,
    /// The ID of the computer tool call that produced the output.
    pub call_id: String,
    /// A JSON string of the output of the function tool call.
    pub output: String,
}

/// A tool call to run a web search.
///
/// See the [web search guide](https://platform.openai.com/docs/guides/tools-web-search) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebSearchCall {
    /// The unique ID of the web search tool call.
    pub id: String,
    /// The status of the web search tool call.
    pub status: String,
}

/// A tool call to run a computer action.
///
/// See the [computer action guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComputerToolCall {
    /// The action to execute.
    pub action: ComputerAction,
    /// The unique ID of the computer call.
    pub call_id: String,
    /// The pending safety checks for the computer call.
    pub pending_safety_checks: Vec<SafetyCheck>,
    /// The status of the item.
    pub status: ComputerCallStatus,
}

/// The action of the computer call.
///
/// See the [computer action guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ComputerAction {
    /// A click action.
    Click {
        /// Indicates which mouse button was pressed during the click.
        button: ClickButton,
        /// The x-coordinate where the click occurred.
        x: u64,
        /// The y-coordinate where the click occurred.
        y: u64,
    },
    /// A double click action.
    DoubleClick {
        /// The x-coordinate where the double click occurred.
        x: u64,
        /// The y-coordinate where the double click occurred.
        y: u64,
    },
    /// A drag action.
    Drag {
        /// An array of coordinates representing the path of the drag action.
        path: Vec<DragCoordinate>,
    },
    #[serde(rename = "keypress")]
    KeyPress {
        /// The combination of keys the model is requesting to be pressed.
        keys: Vec<String>,
    },
    /// A mouse move action.
    Move {
        /// The x-coordinate to move to.
        x: u64,
        /// The y-coordinate to move to.
        y: u64,
    },
    /// A screenshot action.
    Screenshot,
    /// A scroll action.
    Scroll {
        /// The horizontal scroll distance.
        scroll_x: u64,
        /// The vertical scroll distance.
        scroll_y: u64,
        /// The x-coordinate where the scroll occurred.
        x: u64,
        /// The y-coordinate where the scroll occurred.
        y: u64,
    },
    /// An action to type in text.
    Type {
        /// The text to type.
        text: String,
    },
    /// A wait action.
    Wait,
}

/// Indicates which mouse button was pressed during the click.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ClickButton {
    Left,
    Right,
    Wheel,
    Back,
    Forward,
}

/// Represents a coordinate in a drag action.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DragCoordinate {
    /// The x-coordinate of the drag action.
    pub x: u64,
    /// The y-coordinate of the drag action.
    pub y: u64,
}

/// Represents a pending safety check for a computer use call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SafetyCheck {
    /// The type of the pending safety check.
    pub code: String,
    /// The ID of the pending safety check.
    pub id: String,
    /// Details about the pending safety check.
    pub message: String,
}

/// The status of the computer use call.
///
/// See the [computer use guide](https://platform.openai.com/docs/guides/tools-computer-use) for more information.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ComputerCallStatus {
    InProgress,
    Completed,
    Incomplete,
}

/// The output of a computer use call.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ComputerToolCallOutput {
    /// The ID of the computer tool call output. Populated when this item is returned via API.
    pub id: Option<String>,
    /// The status of the item. Populated when items are returned via API.
    pub status: Option<ComputerCallStatus>,
    /// The ID of the computer tool call that produced the output.
    pub call_id: String,
    /// A computer screenshot image used with the computer use tool.
    pub output: ComputerCallOutput,
    /// The safety checks reported by the API that have been acknowledged by the developer.
    pub acknowledged_safety_checks: Option<Vec<SafetyCheck>>,
}

/// A computer screenshot image used with the computer use tool.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type", rename_all = "snake_case")]
pub enum ComputerCallOutput {
    /// A computer screenshot image used with the computer use tool.
    #[serde(rename = "computer_screenshot")]
    Screenshot {
        /// The identifier of an uploaded file that contains the screenshot.
        file_id: Option<String>,
        /// The URL of the screenshot image.
        image_url: Option<String>,
    },
}

/// A description of the chain of thought used by a reasoning model while generating a response.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Reasoning {
    /// The unique identifier of the reasoning content.
    pub id: String,
    /// Reasoning text contents.
    pub summary: Vec<ReasoningSummary>,
    /// The encrypted content of the reasoning item - populated when a response
    /// is generated with reasoning.encrypted_content in the include parameter.
    pub encrypted_content: Option<String>,
    /// The status of the item.
    #[serde(skip_serializing)]
    pub status: Option<ReasoningStatus>,
}

/// Reasoning text contents.
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ReasoningSummary {
    #[serde(rename = "summary_text")]
    Text {
        /// A short summary of the reasoning used by the model when generating the response.
        text: String,
    },
}

/// The status of the reasoning data.
#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum ReasoningStatus {
    InProgress,
    Completed,
    Incomplete,
}

#[cfg(test)]
mod tests {
    use super::{InputItem, OutputMessage};
    use crate::types::{
        APIInputMessage, ContentInput, FunctionCall, MessageStatus, Role, WebSearchCall,
    };
    use serde_json::{Value, from_value, json, to_value};

    #[test]
    fn serialize_input_message() {
        let api_msg = APIInputMessage {
            role: Role::User,
            content: ContentInput::Text("hello".into()),
            status: None,
        };
        let item = InputItem::InputMessage(api_msg);
        let v = to_value(&item).unwrap();
        assert_eq!(v.get("type").and_then(Value::as_str), Some("message"));
        assert_eq!(v.get("role").and_then(Value::as_str), Some("user"));
        assert_eq!(v.get("content"), Some(&Value::String("hello".into())));
        assert!(v.get("status").is_none());
    }

    #[test]
    fn deserialize_input_message() {
        let v = json!({
            "type": "message",
            "role": "developer",
            "content": "foo"
        });
        let item: InputItem = from_value(v).unwrap();
        if let InputItem::InputMessage(wrapper) = item {
            assert_eq!(wrapper.role, Role::Developer);
            if let ContentInput::Text(s) = wrapper.content {
                assert_eq!(s, "foo");
            } else {
                panic!("expected text content");
            }
        } else {
            panic!("expected InputMessage variant");
        }
    }

    #[test]
    fn deserialize_input_message_content_array() {
        let v = json!({
            "type": "message",
            "role": "developer",
            "content": [ ]
        });
        let item: InputItem = from_value(v).unwrap();
        if let InputItem::InputMessage(wrapper) = item {
            assert_eq!(wrapper.role, Role::Developer);
            if let ContentInput::List(s) = wrapper.content {
                assert_eq!(s.len(), 0);
            } else {
                panic!("expected text content");
            }
        } else {
            panic!("expected InputMessage variant");
        }
    }
    #[test]
    fn serialize_output_message() {
        let output = OutputMessage {
            id: "id123".into(),
            role: Role::Assistant,
            status: MessageStatus::Completed,
            content: vec![],
        };
        let item = InputItem::OutputMessage(output);
        let v = to_value(&item).unwrap();
        assert_eq!(v.get("type").and_then(Value::as_str), Some("message"));
        assert_eq!(v.get("id").and_then(Value::as_str), Some("id123"));
        assert_eq!(v.get("role").and_then(Value::as_str), Some("assistant"));
        assert_eq!(v.get("status").and_then(Value::as_str), Some("completed"));
        assert_eq!(v.get("content"), Some(&Value::Array(vec![])));
    }

    #[test]
    fn serialize_function_call_message() {
        let output = FunctionCall {
            id: Some("id123".to_string()),
            arguments: "arguments".to_string(),
            call_id: "call_id".to_string(),
            status: None,
            name: "name".to_string(),
        };
        let item = InputItem::FunctionCall(output);
        let v = to_value(&item).unwrap();
        assert_eq!(v.get("type").and_then(Value::as_str), Some("function_call"));
        assert_eq!(v.get("id").and_then(Value::as_str), Some("id123"));
        assert_eq!(v.get("call_id").and_then(Value::as_str), Some("call_id"));
        assert_eq!(v.get("status").and_then(Value::as_str), None);
        assert_eq!(
            v.get("arguments").and_then(Value::as_str),
            Some("arguments")
        );
    }

    #[test]
    fn deserialize_function_call_message() {
        let v = json!({
            "type": "function_call",
            "id": "out1",
            "call_id": "call_id",
            "arguments": "arguments",
            "name": "name",
        });
        let item: InputItem = from_value(v).unwrap();
        if let InputItem::FunctionCall(output) = item {
            assert_eq!(output.id, Some("out1".to_string()));
            assert_eq!(output.call_id, "call_id".to_string());
            assert_eq!(output.arguments, "arguments");
            assert_eq!(output.name, "name");
            assert_eq!(output.status, None);
        } else {
            panic!("expected OutputMessage variant");
        }
    }

    #[test]
    fn serialize_web_search_message() {
        let output = WebSearchCall {
            id: "id123".to_string(),
            status: "status".to_string(),
        };
        let item = InputItem::WebSearchResults(output);
        let v = to_value(&item).unwrap();
        assert_eq!(
            v.get("type").and_then(Value::as_str),
            Some("web_search_call")
        );
        assert_eq!(v.get("id").and_then(Value::as_str), Some("id123"));
        assert_eq!(v.get("status").and_then(Value::as_str), Some("status"));
    }

    #[test]
    fn deserialize_web_search_message() {
        let v = json!({
            "type": "web_search_call",
            "id": "out1",
            "status": "status",
        });
        let item: InputItem = from_value(v).unwrap();
        if let InputItem::WebSearchResults(output) = item {
            assert_eq!(output.id, "out1".to_string());
            assert_eq!(output.status, "status".to_string());
        } else {
            panic!("expected OutputMessage variant");
        }
    }
}
